<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>F1 MCP WebSocket Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #1a1a1a;
            color: #ffffff;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #e10600;
            border-bottom: 2px solid #e10600;
            padding-bottom: 10px;
        }
        button {
            background-color: #e10600;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:disabled {
            background-color: #cccccc;
        }
        button:hover:not(:disabled) {
            background-color: #b30500;
        }
        pre {
            background-color: #f8f8f8;
            padding: 15px;
            border-radius: 5px;
            overflow: auto;
            max-height: 500px;
            border: 1px solid #ddd;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .connected {
            background-color: #1e4620;
            color: #4caf50;
        }
        .disconnected {
            background-color: #461e1e;
            color: #f44336;
        }
        .driver-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .driver-card {
            background-color: #2d2d2d;
            border-radius: 8px;
            padding: 15px;
        }
        .driver-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #3d3d3d;
            padding-bottom: 10px;
            margin-bottom: 10px;
        }
        .driver-number {
            font-size: 24px;
            font-weight: bold;
        }
        .driver-position {
            font-size: 20px;
            font-weight: bold;
            color: #e10600;
        }
        .driver-data {
            margin-top: 10px;
        }
        .driver-data p {
            margin: 5px 0;
        }
        .session-info {
            background-color: #2d2d2d;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px;
            background-color: #e10600;
            color: white;
            border-radius: 4px;
            display: none;
            z-index: 1000;
        }
        .data-filters {
            background-color: #2d2d2d;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }
        #rawData {
            background-color: #2d2d2d;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            white-space: pre-wrap;
        }
        .chart-container {
            background-color: #2d2d2d;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            height: 300px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>F1 MCP WebSocket Test Client</h1>
        
        <div id="connectionStatus" class="status disconnected">Disconnected</div>
        
        <div>
            <button id="connectBtn">Connect</button>
            <button id="disconnectBtn" disabled>Disconnect</button>
            <button id="mockDataBtn">Toggle Mock Data</button>
            <button id="notifyBtn">Enable Notifications</button>
        </div>
        
        <div class="data-filters">
            <h3>Data Filters</h3>
            <label>
                <input type="checkbox" id="filterLive" checked> Show Live Updates
            </label>
            <label>
                <input type="checkbox" id="filterTelemetry" checked> Show Telemetry
            </label>
            <select id="driverFilter">
                <option value="all">All Drivers</option>
            </select>
        </div>
        
        <h2>Session Information</h2>
        <div id="sessionInfo" class="session-info">
            <p>No session data available</p>
        </div>
        
        <div class="chart-container">
            <canvas id="telemetryChart"></canvas>
        </div>
        
        <h2>Driver Data</h2>
        <div id="driverGrid" class="driver-grid">
            <p>No driver data available</p>
        </div>
        
        <h2>Raw Data</h2>
        <pre id="rawData">Waiting for data...</pre>
    </div>

    <div id="notification" class="notification"></div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        let socket = null;
        let mockDataEnabled = false;
        let notificationsEnabled = false;
        let lastSessionStatus = null;
        let telemetryChart = null;
        let driverData = {};
        let lastData = null;
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const mockDataBtn = document.getElementById('mockDataBtn');
        const notifyBtn = document.getElementById('notifyBtn');
        const output = document.getElementById('rawData');
        const connectionStatus = document.getElementById('connectionStatus');
        const sessionInfo = document.getElementById('sessionInfo');
        const driverGrid = document.getElementById('driverGrid');
        
        // Initialize the telemetry chart
        function initChart() {
            const ctx = document.getElementById('telemetryChart').getContext('2d');
            telemetryChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    scales: {
                        x: {
                            type: 'linear',
                            display: true,
                            title: {
                                display: true,
                                text: 'Time'
                            },
                            ticks: {
                                color: '#ffffff'
                            },
                            grid: {
                                color: '#3d3d3d'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Speed (km/h)'
                            },
                            ticks: {
                                color: '#ffffff'
                            },
                            grid: {
                                color: '#3d3d3d'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            labels: {
                                color: '#ffffff'
                            }
                        },
                        title: {
                            display: true,
                            text: 'Driver Speed Telemetry',
                            color: '#ffffff',
                            font: {
                                size: 16
                            }
                        }
                    }
                }
            });

            // Start with empty data
            telemetryChart.data.labels = Array(20).fill('');
            telemetryChart.data.datasets = [];
            telemetryChart.update();
        }
        
        connectBtn.addEventListener('click', connect);
        disconnectBtn.addEventListener('click', disconnect);
        mockDataBtn.addEventListener('click', toggleMockData);
        notifyBtn.addEventListener('click', () => {
            notificationsEnabled = !notificationsEnabled;
            notifyBtn.textContent = notificationsEnabled ? 'Disable Notifications' : 'Enable Notifications';
        });
        
        function connect() {
            const clientId = 'client_' + Math.random().toString(36).substr(2, 9);
            socket = new WebSocket(`ws://localhost:8000/ws/${clientId}`);
            
            socket.onopen = function(e) {
                connectionStatus.textContent = 'Connected to F1 MCP Server';
                connectionStatus.className = 'status connected';
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
                output.textContent = 'Waiting for data...';
                showNotification('Connected to F1 MCP Server');
            };
            
            socket.onmessage = function(event) {
                const data = JSON.parse(event.data);
                lastData = data;
                
                if (document.getElementById('filterLive').checked) {
                    output.textContent = JSON.stringify(data, null, 2);
                    updateSessionInfo(data.data.session);
                    updateDriverGrid(data.data.drivers);
                }
                
                if (document.getElementById('filterTelemetry').checked) {
                    updateChart(data.data);
                }
            };
            
            socket.onclose = function(event) {
                connectionStatus.textContent = 'Disconnected from F1 MCP Server';
                connectionStatus.className = 'status disconnected';
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
                showNotification('Disconnected from F1 MCP Server');
            };
            
            socket.onerror = function(error) {
                console.error('WebSocket error:', error);
                showNotification('Error connecting to F1 MCP Server');
            };
        }
        
        function disconnect() {
            if (socket) {
                socket.close();
            }
        }

        async function toggleMockData() {
            mockDataEnabled = !mockDataEnabled;
            try {
                const response = await fetch(`http://localhost:8000/mock/${mockDataEnabled}`);
                const data = await response.json();
                mockDataBtn.textContent = mockDataEnabled ? 'Disable Mock Data' : 'Enable Mock Data';
                showNotification(`Mock data ${mockDataEnabled ? 'enabled' : 'disabled'}`);
            } catch (error) {
                console.error('Error toggling mock data:', error);
                showNotification('Error toggling mock data');
            }
        }
        
        function updateSessionInfo(session) {
            if (!session) {
                sessionInfo.innerHTML = '<p>No session data available</p>';
                return;
            }
            
            // Check for session status change
            if (lastSessionStatus !== session.session_status) {
                if (session.session_status === 'Live') {
                    showNotification('Session is now live!');
                }
                lastSessionStatus = session.session_status;
            }
            
            sessionInfo.innerHTML = `
                <p><strong>Session:</strong> ${session.session_name}</p>
                <p><strong>Track:</strong> ${session.track_name}</p>
                <p><strong>Date:</strong> ${new Date(session.session_date).toLocaleString()}</p>
                <p><strong>Status:</strong> ${session.session_status}</p>
                <p><strong>Data Source:</strong> ${session.source_info ? `Telemetry: ${session.source_info.telemetry}, Historical: ${session.source_info.historical}` : 'Unknown'}</p>
                ${session.weather ? `
                    <p><strong>Air Temp:</strong> ${session.air_temp}°C</p>
                    <p><strong>Track Temp:</strong> ${session.track_temp}°C</p>
                    <p><strong>Wind Speed:</strong> ${session.weather.wind_speed} km/h</p>
                    <p><strong>Humidity:</strong> ${session.weather.humidity}%</p>
                ` : ''}
            `;
        }
        
        function updateDriverGrid(drivers) {
            if (!drivers || Object.keys(drivers).length === 0) {
                driverGrid.innerHTML = '<p>No driver data available</p>';
                return;
            }
            
            const selectedDriver = document.getElementById('driverFilter').value;
            
            // Update driver filter options if needed
            const driverFilter = document.getElementById('driverFilter');
            if (driverFilter.children.length <= 1) {
                Object.values(drivers).forEach(driver => {
                    const option = document.createElement('option');
                    option.value = driver.driver_number;
                    option.textContent = driver.driver_name;
                    driverFilter.appendChild(option);
                });
            }

            // Filter drivers if needed
            const driversToShow = selectedDriver === 'all' ? 
                drivers : 
                { [selectedDriver]: drivers[selectedDriver] };

            driverGrid.innerHTML = Object.values(driversToShow)
                .sort((a, b) => (a.position || 999) - (b.position || 999))
                .map(driver => `
                    <div class="driver-card">
                        <div class="driver-header">
                            <span class="driver-number">${driver.driver_number}</span>
                            <span class="driver-position">P${driver.position || '-'}</span>
                        </div>
                        <div class="driver-data">
                            <p><strong>Driver:</strong> ${driver.driver_name}</p>
                            <p><strong>Team:</strong> ${driver.team}</p>
                            <p><strong>Last Lap:</strong> ${formatTime(driver.last_lap_time)}</p>
                            <p><strong>Best Lap:</strong> ${formatTime(driver.best_lap_time)}</p>
                            <p><strong>Gap to Leader:</strong> ${driver.gap_to_leader ? `+${driver.gap_to_leader.toFixed(3)}` : '-'}</p>
                            <p><strong>Current Speed:</strong> ${driver.speed ? `${driver.speed.toFixed(1)} km/h` : '-'}</p>
                            <p><strong>Tire:</strong> ${driver.tire_compound || '-'}</p>
                            <p><strong>Pit Stops:</strong> ${driver.pit_stops || '0'}</p>
                            ${driver.sector_times ? `
                                <p><strong>Sectors:</strong> 
                                    S1: ${formatTime(driver.sector_times.S1)}, 
                                    S2: ${formatTime(driver.sector_times.S2)}, 
                                    S3: ${formatTime(driver.sector_times.S3)}
                                </p>
                            ` : ''}
                        </div>
                    </div>
                `).join('');
        }
        
        function formatTime(seconds) {
            if (!seconds) return '-';
            
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = (seconds % 60).toFixed(3);
            
            if (minutes > 0) {
                return `${minutes}:${remainingSeconds.padStart(6, '0')}`;
            } else {
                return remainingSeconds;
            }
        }

        function showNotification(message) {
            if (!notificationsEnabled) return;
            
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 5000);
        }

        function updateChart(data) {
            if (!telemetryChart) return;
            
            const selectedDriver = document.getElementById('driverFilter').value;
            const timestamp = new Date().toLocaleTimeString();

            // Remove old data points if we have too many
            if (telemetryChart.data.labels.length > 20) {
                telemetryChart.data.labels.shift();
                telemetryChart.data.datasets.forEach(dataset => dataset.data.shift());
            }

            // Add new timestamp
            telemetryChart.data.labels.push(timestamp);

            if (selectedDriver === 'all') {
                // Update for all drivers
                const existingDrivers = new Set(telemetryChart.data.datasets.map(d => d.label));
                const currentDrivers = new Set(Object.values(data.drivers).map(d => d.driver_name));

                // Remove datasets for drivers no longer present
                telemetryChart.data.datasets = telemetryChart.data.datasets.filter(dataset => 
                    currentDrivers.has(dataset.label)
                );

                // Update or add datasets for current drivers
                Object.values(data.drivers).forEach(driver => {
                    let dataset = telemetryChart.data.datasets.find(d => d.label === driver.driver_name);
                    
                    if (!dataset) {
                        dataset = {
                            label: driver.driver_name,
                            data: new Array(telemetryChart.data.labels.length - 1).fill(null),
                            borderColor: getTeamColor(driver.team),
                            fill: false,
                            tension: 0.4
                        };
                        telemetryChart.data.datasets.push(dataset);
                    }
                    
                    dataset.data.push(driver.speed || null);
                });
            } else {
                // Update for selected driver
                const driver = data.drivers[selectedDriver];
                if (driver) {
                    if (telemetryChart.data.datasets.length === 0) {
                        telemetryChart.data.datasets.push({
                            label: driver.driver_name,
                            data: new Array(telemetryChart.data.labels.length - 1).fill(null),
                            borderColor: getTeamColor(driver.team),
                            fill: false,
                            tension: 0.4
                        });
                    }
                    telemetryChart.data.datasets[0].data.push(driver.speed || null);
                }
            }
            
            telemetryChart.update('none');
        }

        function getTeamColor(team) {
            const teamColors = {
                'Mercedes': '#00D2BE',
                'Red Bull Racing': '#0600EF',
                'Ferrari': '#DC0000',
                'McLaren': '#FF8700',
                'Aston Martin': '#006F62',
                'Alpine': '#0090FF',
                'Williams': '#005AFF',
                'AlphaTauri': '#2B4562',
                'Alfa Romeo': '#900000',
                'Haas F1 Team': '#FFFFFF'
            };
            return teamColors[team] || '#666666';
        }

        document.getElementById('driverFilter').addEventListener('change', () => {
            if (lastData) {
                updateDriverGrid(lastData.data.drivers);
                updateChart(lastData.data);
            }
        });

        // Initialize chart
        initChart();
    </script>
</body>
</html> 